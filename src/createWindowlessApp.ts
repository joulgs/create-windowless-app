import * as commander from "commander";
import chalk from "chalk";
import * as envinfo from "envinfo";
import * as path from "path";
import * as fs from "fs-extra";
import * as  validateProjectName from 'validate-npm-package-name';
import { Command } from "commander";

const packageJson = require('../package.json');

const consts = require('../resources/consts.json');

// These files should be allowed to remain on a failed install,
// but then silently removed during the next create.
const errorLogFilePatterns = [
    'npm-debug.log',
    'yarn-error.log',
    'yarn-debug.log',
];

export function createWindowlessApp() {
    let projectName: string = undefined;

    const program: Command = new commander.Command(packageJson.name)
        .version(packageJson.version)
        .arguments('<project-directory>')
        .usage(`${ chalk.green('<project-directory>') } [options]`)
        .action(name => {
            projectName = name;
        })
        .option('--verbose', 'print additional logs')
        .option('--info', 'print environment debug info')
        .option('--typescript')
        .allowUnknownOption()
        .on('--help', () => {
            console.log(`    Only ${ chalk.green('<project-directory>') } is required.`);
            console.log();
            console.log(`    If you have any problems, do not hesitate to file an issue:`);
            console.log(`      ${ chalk.cyan('https://github.com/yoavain/create-windowless-app/issues/new') }`);
            console.log();
        })
        .parse(process.argv);

    if (program.info) {
        console.log(chalk.bold('\nEnvironment Info:'));
        return envinfo
            .run({
                    System: ['OS', 'CPU'],
                    Binaries: ['Node', 'npm'],
                    npmPackages: consts.dependencies,
                    npmGlobalPackages: ['create-windowless-app'],
                },
                {
                    duplicates: true,
                    showNotFound: true,
                }
            )
            .then(console.log);
    }

    if (typeof projectName === 'undefined') {
        console.error('Please specify the project directory:');
        console.log(`  ${ chalk.cyan(program.name()) } ${ chalk.green('<project-directory>') }`);
        console.log();
        console.log('For example:');
        console.log(`  ${ chalk.cyan(program.name()) } ${ chalk.green('my-windowless-app') }`);
        console.log();
        console.log(`Run ${ chalk.cyan(`${ program.name() } --help`) } to see all options.`);
        process.exit(1);
    }

    function printValidationResults(results) {
        if (typeof results !== 'undefined') {
            results.forEach(error => {
                console.error(chalk.red(`  *  ${ error }`));
            });
        }
    }

    const hiddenProgram = new commander.Command()
        .option('--internal-testing-template <path-to-template>', `(internal usage only, DO NOT RELY ON THIS) use a non-standard application template`)
        .parse(process.argv);

    createApp(projectName, program.verbose, program.typescript);
}

function createApp(name: string, verbose: boolean, useTypescript: boolean) {
    const root = path.resolve(name);
    const appName = path.basename(root);

    checkAppName(appName);
    fs.ensureDirSync(name);
    if (!isSafeToCreateProjectIn(root, name)) {
        process.exit(1);
    }
}

function checkAppName(appName) {
    const validationResult = validateProjectName(appName);
    if (!validationResult.validForNewPackages) {
        console.error(`Could not create a project called ${ chalk.red(`"${ appName }"`) } because of npm naming restrictions:`);
        printValidationResults(validationResult.errors);
        printValidationResults(validationResult.warnings);
        process.exit(1);
    }

    const dependencies = consts.dependencies.sort();
    if (dependencies.indexOf(appName) >= 0) {
        console.error(chalk.red(`We cannot create a project called ${ chalk.green(appName) } because a dependency with the same name exists.\n` +
            `Due to the way npm works, the following names are not allowed:\n\n`) +
            chalk.cyan(dependencies.map(depName => `  ${ depName }`).join('\n')) +
            chalk.red('\n\nPlease choose a different project name.')
        );
        process.exit(1);
    }
}

function printValidationResults(results) {
    if (typeof results !== 'undefined') {
        results.forEach(error => {
            console.error(chalk.red(`  *  ${ error }`));
        });
    }
}

// If project only contains files generated by GH, itâ€™s safe.
// Also, if project contains remnant error logs from a previous
// installation, lets remove them now.
// We also special case IJ-based products .idea because it integrates with CRA:
// https://github.com/facebook/create-react-app/pull/368#issuecomment-243446094
function isSafeToCreateProjectIn(root, name) {
    const validFiles = [
        '.DS_Store',
        'Thumbs.db',
        '.git',
        '.gitignore',
        '.idea',
        'README.md',
        'LICENSE',
        '.hg',
        '.hgignore',
        '.hgcheck',
        '.npmignore',
        'mkdocs.yml',
        'docs',
        '.travis.yml',
        '.gitlab-ci.yml',
        '.gitattributes',
    ];
    console.log();

    const conflicts = fs
        .readdirSync(root)
        .filter(file => !validFiles.includes(file))
        // IntelliJ IDEA creates module files before CRA is launched
        .filter(file => !/\.iml$/.test(file))
        // Don't treat log files from previous installation as conflicts
        .filter(file => !errorLogFilePatterns.some(pattern => file.indexOf(pattern) === 0));

    if (conflicts.length > 0) {
        console.log(`The directory ${ chalk.green(name) } contains files that could conflict:`);
        console.log();
        for (const file of conflicts) {
            console.log(`  ${ file }`);
        }
        console.log();
        console.log('Either try using a new directory name, or remove the files listed above.');

        return false;
    }

    // Remove any remnant files from a previous installation
    const currentFiles = fs.readdirSync(path.join(root));
    currentFiles.forEach(file => {
        errorLogFilePatterns.forEach(errorLogFilePattern => {
            // This will catch `(npm-debug|yarn-error|yarn-debug).log*` files
            if (file.indexOf(errorLogFilePattern) === 0) {
                fs.removeSync(path.join(root, file));
            }
        });
    });
    return true;
}